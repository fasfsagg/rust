searchState.loadedDescShard("h3_quinn", 0, "QUIC Transport implementation with Quinn\nFuture produced by <code>Connection::accept_bi</code>\nFuture produced by <code>Connection::accept_uni</code>\nQuinn-backed bidirectional stream\nA QUIC connection backed by Quinn\nThe error type for <code>Connection</code>\nNetwork error\nThe connection was lost\nDatagrams are locally disabled\nA QUIC endpoint.\nThe largest representable value\nThe largest encoded value length\nError when the stream is not ready, because it is still …\nFuture produced by <code>Connection::open_bi</code>\nStream opener backed by a Quinn connection\nFuture produced by <code>Connection::open_uni</code>\nThe error type for <code>RecvStream</code>\nQuinn-backed receive stream\nTypes of errors when sending a datagram.\nQuinn-backed send stream\nThe error type for <code>SendStream</code>\nA cryptographic session (commonly TLS)\nThe peer is no longer accepting data on this stream\nThe datagram was too large to be sent.\nThe stream has already been finished or reset\nDatagrams are not supported by the peer\nAn integer less than 2^62\nErrors when writing, wrapping a <code>quinn::WriteError</code>\nErrors that arise from writing to a stream\nThis was a 0-RTT stream and the server rejected it\nGet the next incoming connection attempt from a client\nHelper to construct an endpoint for use with outgoing …\nClose all of this endpoint’s connections immediately and …\nConnect to a remote endpoint\nConnect to a remote endpoint using a custom configuration.\nGet the 0-RTT keys if available (clients only)\nIf the 0-RTT-encrypted data has been accepted by the peer\nFill <code>output</code> with <code>output.len()</code> bytes of keying material …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>VarInt</code> infallibly\nSucceeds iff <code>x</code> &lt; 2^62\nCreate a VarInt without ensuring it’s in range\nGet data negotiated during the handshake, if available\nCreate the initial set of keys given the client’s …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtract the integer value\nReturns <code>true</code> until the connection is fully established.\nVerify the integrity of a retry packet\nGet the local <code>SocketAddr</code> the underlying socket is bound to\nCreate a <code>Connection</code> from a <code>quinn::Connection</code>\nConstruct an endpoint with arbitrary configuration and …\nConstruct an endpoint with arbitrary configuration and …\nCompute keys for the next key update\nGet the peer’s identity, if available\nRead bytes of handshake data\nSwitch to a new UDP socket\nReject new incoming connections without affecting existing …\nHelper to construct an endpoint for use with both incoming …\nSet the client configuration used by <code>connect</code>\nReplace the server configuration, affecting new incoming …\nThe peer’s QUIC transport parameters\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nSucceeds iff <code>x</code> &lt; 2^62\nWait for all connections on the endpoint to be cleanly …\nWrites handshake bytes into the given buffer and …")