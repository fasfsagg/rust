searchState.loadedDescShard("h3", 0, "HTTP/3 client and server\nClient implementation of the HTTP/3 protocol\nHTTP/3 Error types\nExtensions for the HTTP/3 protocol.\nQUIC Transport traits\nThis module provides methods to create a http/3 Server.\nHTTP/3 client builder\nClient connection driver\nManage request bodies transfer, response and trailers.\nHTTP/3 request sender\nCreate a new HTTP/3 client from a <code>quic</code> connection\nStart building a new HTTP/3 client\nEnd the request without trailers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the maximum header size this client is willing to …\nCreate a new HTTP/3 client with default settings\nMaintain the connection state until it is closed\nReceive some of the request body.\nReceive the HTTP/3 response\nReceive an optional set of trailers for the response.\nSend some data on the request body.\nJust like in HTTP/2, HTTP/3 also uses the concept of “…\nSend a HTTP/3 request to the server\nSend a set of trailers to end the request.\nInitiate a graceful shutdown, accepting <code>max_push</code> …\nSplit this stream into two halves that can be driven …\nTell the peer to stop sending into the underlying QUIC …\nWait until the connection is closed\nAn HTTP/3 “application error code”.\nError that will close the whole connection\nA general error that can occur when handling the HTTP/3 …\nSome errors affect the whole connection, others only one …\nA stream required by the HTTP/3 connection was closed or …\nThe TCP connection established in response to a CONNECT …\nDatagram or capsule parse error See: …\nThe endpoint detected that its peer is exhibiting a …\nA frame that fails to satisfy layout requirements or with …\nA frame was received that was not permitted in the current …\nPeer violated protocol requirements in a way that does not …\nA Stream ID or Push ID was used incorrectly, such as …\nAn internal error has occurred in the HTTP stack.\nAn HTTP message was malformed and cannot be processed.\nNo SETTINGS frame was received at the beginning of the …\nNo error. This is used when the connection or stream needs …\nThe request or its response (including pushed response) is …\nThe client’s stream terminated without containing a …\nA server rejected a request without performing any …\nAn endpoint detected an error in the payload of a SETTINGS …\nThe endpoint detected that its peer created a stream that …\nThe requested operation cannot be served over HTTP/3. The …\nThe encoder failed to interpret a decoder instruction …\nThe decoder failed to interpret an encoded field section …\nThe decoder failed to interpret an encoder instruction …\nError scoped to a single stream\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturns the <code>ErrorLevel</code> of an <code>Error</code> This indicates weather …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the error code from the error if available\nNumerical error code\nRFC 9298 protocol\nHTTP datagram frames See: …\nError when parsing the protocol\nDescribes the <code>:protocol</code> pseudo-header for extended connect\nWebTransport protocol\nReturn a &amp;str representation of the <code>:protocol</code> …\nDecodes a datagram frame from the QUIC datagram\nEncode the datagram to wire format\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the datagram payload\nCreates a new datagram frame\nReturns the datagram payload\nReturns the associated stream id of the datagram\nOptional trait to allow “splitting” a bidirectional …\nThe type produced by <code>poll_accept_bidi()</code>\nThe type produced by <code>poll_open_bidi()</code>\nThe type of <code>Buf</code> for <em>raw</em> datagrams (without the stream_id …\nThe type of <code>Buf</code> for data received on this stream.\nTrait representing a QUIC connection.\nTrait that represent an error from the transport layer\nError type yielded by this trait methods\nThe error type that can occur when sending a datagram\nThe error type that can occur when receiving a datagram\nError type yielded by these trait methods\nThe error type returned by fallible send methods.\nThe error type that can occur when receiving data.\nInvalid StreamId, for example because it’s too large\nTrait for opening outgoing streams\nA producer of outgoing Unidirectional and Bidirectional …\nExtends the <code>Connection</code> trait for receiving datagrams\nA trait describing the “receive” actions of a QUIC …\nThe type produced by <code>poll_accept_recv()</code>\nThe type of the receiving part of <code>BidiStream</code>\nThe type for the receive half.\nExtends the <code>Connection</code> trait for sending datagrams\nA trait describing the “send” actions of a QUIC stream.\nThe type of the sending part of <code>BidiStream</code>\nThe type produced by <code>poll_open_send()</code>\nThe type for the send half.\nAllows sending unframed pure bytes to a stream. Similar to …\nIdentifier for a stream\nWrap frames to encode their header on the stack before …\nClose the connection immediately\nClose the connection immediately\nGet the QUIC error code from connection close or stream …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDistinguishes streams of the same initiator and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this a server push?\nIs this a client-initiated request?\nCheck if the current error is a transport timeout\nGet an object to open outgoing streams.\nAccept an incoming bidirectional stream\nPoll the connection for incoming datagrams.\nAccept an incoming unidirectional stream\nPoll the stream for more data.\nPoll to finish the sending side of the stream.\nPoll the connection to create a new bidirectional stream.\nPoll the connection to create a new bidirectional stream.\nPoll the connection to create a new unidirectional stream.\nPoll the connection to create a new unidirectional stream.\nPolls if the stream can send more data.\nAttempts write data into the stream.\nGet QUIC send stream id\nSend a QUIC reset code.\nSend more data on the stream.\nSend a datagram\nGet QUIC send stream id\nSplit this stream into two halves.\nSend a <code>STOP_SENDING</code> QUIC code.\nBuilder of HTTP/3 server connections.\nServer connection driver\nFuture for <code>Connection::read_datagram</code>\nManage request and response transfer for an incoming …\nAccept an incoming request.\nAccepts an http request where the first frame has already …\nBuild an HTTP/3 connection from a QUIC connection\nCreate a builder of HTTP/3 server connections\nCloses the connection with a code and a reason.\nEnables the CONNECT protocol\nIndicates that the client or server supports HTTP/3 …\nIndicates to the peer that WebTransport is supported.\nEnd the response without trailers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the underlying stream id\nTODO: temporarily break encapsulation for …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the maximum header size this client is willing to …\nLimits the maximum number of WebTransport sessions\nCreate a new HTTP/3 server connection with default settings\nAccepts an incoming bidirectional stream.\nReads an incoming datagram\nReceive data sent from the client\nReceive an optional set of trailers for the request\nSend some data on the response body.\nSends a datagram\nSend grease values to the Client. See setting, frame and …\nReturns the underlying stream id\nSend the HTTP/3 response\nSend a set of trailers to end the response.\nInitiate a graceful shutdown, accepting <code>max_request</code> …\nSplits the Request-Stream into send and receive. This can …\nTell the peer to stop sending into the underlying QUIC …\nStop a stream with an error code")