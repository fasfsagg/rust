<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src\app\service\task_service.rs`."><title>task_service.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../..\../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../..\../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../..\../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../..\../" data-static-root-path="../../..\../static.files/" data-current-crate="axum_tutorial" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.1 (4eb161250 2025-03-15)" data-channel="1.85.1" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../..\../static.files/storage-59e33391.js"></script><script defer src="../../..\../static.files/src-script-56102188.js"></script><script defer src="../../..\../src-files.js"></script><script defer src="../../..\../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../..\../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../..\../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../..\../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">axum_tutorial\app\service/</div>task_service.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers">
<a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a></pre></div><pre class="rust"><code><span class="comment">// app/service/task_service.rs
//
// 【任务服务模块】
// 这个模块实现了任务相关的业务逻辑，它是服务层的一部分。
// 服务层负责处理业务规则和流程，它调用数据访问层执行数据操作。
//
// 分层设计的好处体现在这里：
// - 业务逻辑与数据访问分离，每层专注于自己的职责
// - 控制器层调用服务层，服务层调用数据层，保持清晰的依赖方向
// - 服务层可以被单元测试，不需要HTTP请求和响应的复杂模拟

// /-------------------------------------------------------------------------\
// |                           【模块功能图示】                            |
// |-------------------------------------------------------------------------|
// |   控制器层 (Controller Layer)                                           |
// |        |                                                                |
// |        | 调用服务函数 (Calls Service Functions)                        |
// |        V                                                                |
// | +---------------------------------------------------------------------+ |
// | |                 task_service.rs (本模块)                          | |
// | |---------------------------------------------------------------------| |
// | | 依赖项 (Dependencies):                                              | |
// | |  - `model::{Task, CreateTaskPayload, UpdateTaskPayload}` (模型)    | |
// | |  - `db::{self, Db}` (数据访问层函数和类型)                          | |
// | |  - `error::Result` (自定义 Result 类型)                            | |
// | |  - `uuid::Uuid`                                                      | |
// | |---------------------------------------------------------------------| |
// | | 公共函数 (业务逻辑):                                                | |
// | |  - async fn create_task(db: &amp;Db, payload: CreateTaskPayload)      | |
// | |      -&gt; Result&lt;Task&gt;                                                | |
// | |          |-&gt; 调用 db::create_task(...)                           | |
// | |  - async fn get_all_tasks(db: &amp;Db) -&gt; Vec&lt;Task&gt;                     | |
// | |          |-&gt; 调用 db::get_all_tasks(...)                          | |
// | |  - async fn get_task_by_id(db: &amp;Db, id: Uuid) -&gt; Result&lt;Task&gt;       | |
// | |          |-&gt; 调用 db::get_task_by_id(...)                         | |
// | |  - async fn update_task(db: &amp;Db, id: Uuid, payload: UpdateTaskPayload)| |
// | |      -&gt; Result&lt;Task&gt;                                                | |
// | |          |-&gt; 调用 db::update_task(...)                           | |
// | |  - async fn delete_task(db: &amp;Db, id: Uuid) -&gt; Result&lt;Task&gt;       | |
// | |          |-&gt; 调用 db::delete_task(...)                           | |
// | +---------------------------------------------------------------------+ |
// |        |                                                                |
// |        | 调用数据访问层函数 (Calls Data Access Layer Functions)        |
// |        V                                                                |
// |   数据访问层 (Data Access Layer - db.rs)                                |
// \-------------------------------------------------------------------------/
//
// 文件路径: src/app/service/task_service.rs
//
// 【模块核心职责】
// 这个模块是应用程序的【服务层 (Service Layer)】的一部分，专门负责处理与"任务"相关的【业务逻辑】。
// 它是连接控制器层 (Controller) 和数据访问层 (DB) 的桥梁。
//
// 【主要职责】
// 1. **实现业务规则**: 封装应用程序的核心业务流程和规则。例如，创建任务时可能需要检查标题是否唯一（本项目未实现），更新任务时可能需要验证用户权限等。
// 2. **协调数据操作**: 调用数据访问层 (`db.rs`) 提供的函数来执行实际的数据持久化操作（增删改查）。服务层本身不直接与数据库交互。
// 3. **处理输入和输出**: 接收来自控制器层的数据（通常是 DTO，如 `CreateTaskPayload`），处理后可能返回领域模型对象（如 `Task`）或结果。
// 4. **事务管理（如果需要）**: 在涉及多个数据操作的复杂业务流程中，服务层通常负责管理数据库事务的开始、提交或回滚（在本项目内存数据库中不涉及）。
//
// 【分层架构中的地位】
// - **隔离关注点**: 将业务逻辑与 HTTP 处理（Controller）和数据存储（DB）分离开来。
// - **可测试性**: 服务层的函数通常是纯粹的业务逻辑，不依赖于 Web 框架的具体实现，更容易进行单元测试。
// - **可重用性**: 业务逻辑被封装在服务层，可以被不同的入口（如 HTTP API、命令行工具、定时任务等）复用。
//
// 【关键技术点】
// - **`async fn`**: 这些函数被标记为【异步函数】。[[Rust语法特性/概念: 异步编程]]
//   - 在 Rust 中，`async fn` 表示这个函数可以被【暂停 (suspend)】并在等待某个操作（通常是 I/O 操作，如数据库查询、网络请求）完成时让出当前线程，允许其他任务运行。
//   - 使用 `async/await` 语法可以编写看起来像同步代码的异步逻辑。
//   - **注意**: 虽然这个项目中的 `db.rs` 使用的是内存同步操作，但服务层接口设计为 `async fn` 是一个【良好实践】，因为它使得未来切换到真正的异步数据库驱动（如 `sqlx`, `tokio-postgres`）时，服务层的函数签名【无需改变】。
// - **依赖注入 (通过参数传递)**: 数据库实例 `db: &amp;db::Db` 是作为参数传递给每个服务函数的。这是一种简单的【依赖注入】形式，使得服务函数不直接依赖于全局状态，更容易测试（可以传入模拟的 `Db` 实例）。
// - **错误处理**: 函数返回 `Result&lt;T&gt;`（即 `Result&lt;T, AppError&gt;`），统一处理可能发生的错误（如 `TaskNotFound`）。
// - **结构体解构**: 使用 `let CreateTaskPayload { ... } = payload;` 语法可以方便地从载荷结构体中提取字段。[[关键语法要素: 解构]]
//
// 【面向初学者提示】
// - **业务逻辑**: 指的是应用程序要解决的特定问题的规则和流程。例如，"创建一个新任务需要标题，并且标题不能为空"就是一个简单的业务规则。
// - **服务层**: 就像一个部门经理。控制器（前台）接到客户请求（HTTP Request），将请求信息（Payload）交给经理（Service Function）。经理根据公司规定（业务逻辑）处理信息，并指示下属（DB Function）去文件柜（数据库）存取文件（数据），最后将处理结果返回给前台。
// - **异步编程**: 想象一下在厨房做饭。同步方式是：烧水-&gt;等水开-&gt;煮面-&gt;等面熟。异步方式是：开始烧水（不等它开），同时去切菜，水开了再去煮面（不等它熟），同时去准备调料。异步允许程序在等待耗时操作（如烧水、煮面、数据库查询）时去做其他事情，提高效率。

// --- 导入依赖 ---
// 导入模型层定义的结构体：任务实体 `Task`，以及用于创建和更新的载荷。
</span><span class="kw">use </span><span class="kw">crate</span>::app::model::{ CreateTaskPayload, Task, UpdateTaskPayload };
<span class="comment">// 导入数据访问层 (`db.rs`) 的所有公共项（主要是 CRUD 函数和 `Db` 类型）。
// `crate::db` 表示从当前 crate 的根目录开始查找 `db` 模块。
</span><span class="kw">use </span><span class="kw">crate</span>::db;
<span class="comment">// 导入自定义的 `Result` 类型别名，用于统一函数返回值。
</span><span class="kw">use </span><span class="kw">crate</span>::error::Result;
<span class="comment">// 导入 `Uuid` 类型，用于标识任务。
</span><span class="kw">use </span>uuid::Uuid;

<span class="comment">// --- 服务函数定义 ---

</span><span class="doccomment">/// 服务函数：创建新任务 (Service Function: Create Task)
///
/// 【功能】: 处理创建新任务的核心业务流程。
/// 【输入】: 数据库访问接口 (`db`) 和 从 Controller 传来的已解析的请求载荷 (`payload`)。
/// 【输出】: 一个包含新创建 `Task` 或错误的 `Result`。
/// 【标记】: `pub async fn` - 定义一个公共的异步函数。[[关键语法要素: pub, async, fn]]
///
/// # 【参数】
/// * `db: &amp;db::Db` - 对数据库实例的【不可变引用】。服务函数通过它调用 `db.rs` 中的函数。
/// * `payload: CreateTaskPayload` - 创建任务所需的数据。[[所有权: 移动]] (Controller 将 Payload 的所有权转移给这个函数)
///
/// # 【返回值】
/// * `-&gt; Result&lt;Task&gt;`: 返回一个 `Result`。
///    - `Ok(Task)`: 成功时，包含新创建的任务实体。
///    - `Err(AppError)`: 失败时，包含一个描述错误的 `AppError`。
</span><span class="kw">pub async fn </span>create_task(db: <span class="kw-2">&amp;</span>db::Db, payload: CreateTaskPayload) -&gt; <span class="prelude-ty">Result</span>&lt;Task&gt; {
    <span class="comment">// --- 业务逻辑占位符 ---
    // 在一个更完整的应用程序中，这里会是实现具体业务规则的地方。
    // 例如：
    // 1. **输入验证**: 检查 `payload.title` 是否为空，长度是否符合要求等（虽然部分验证可能在 Controller 或 Model 层做）。
    //    ```rust
    //    if payload.title.is_empty() {
    //        return Err(AppError::ValidationError("标题不能为空".to_string()));
    //    }
    //    ```
    // 2. **默认值处理**: 如果某些字段有更复杂的默认逻辑。
    // 3. **唯一性检查**: 查询数据库确保不存在同名任务（如果需要）。
    //    ```rust
    //    // 伪代码: 需要添加相应的 db 函数
    //    // if db::task_exists_with_title(db, &amp;payload.title).await? {
    //    //     return Err(AppError::BusinessRuleViolation("任务标题已存在".to_string()));
    //    // }
    //    ```
    // 4. **权限检查**: 检查当前用户是否有权创建任务。
    // 5. **审计日志**: 记录谁在什么时间创建了任务。
    // 6. **触发事件/通知**: 例如，任务创建后发送通知给相关人员。
    </span><span class="macro">println!</span>(<span class="string">"SERVICE: 正在处理创建任务请求..."</span>); <span class="comment">// 简单的日志

    // --- 解构 Payload ---
    // 使用模式匹配将 `payload` 结构体的字段解构到独立的变量中。
    // 这使得后续调用 `db::create_task` 时传递参数更清晰。
    </span><span class="kw">let </span>CreateTaskPayload { title, description, completed } = payload;

    <span class="comment">// --- 调用数据访问层 ---
    // 调用 `db.rs` 中定义的 `create_task` 函数来执行实际的数据库插入操作。
    // 将从 `payload` 解构出来的字段传递给数据库函数。
    // **关于 `await`**: 虽然 `db::create_task` 在我们当前的内存实现中是同步的，
    // 但由于 `create_task` (本函数) 被声明为 `async`，理论上它调用的其他 `async` 函数需要使用 `.await`。
    // 不过，Rust 编译器足够智能，如果调用的函数 (`db::create_task`) 不是 `async fn`，
    // 则不需要也不能使用 `.await`。如果未来 `db::create_task` 变为 `async`，则需要在这里加上 `.await`。
    // 即 `db::create_task(db, title, description, completed).await?` (如果它返回 Result)
    // 或者 `db::create_task(db, title, description, completed).await` (如果它直接返回 Task)
    </span><span class="kw">let </span>result = db::create_task(db, title, description, completed);

    <span class="macro">println!</span>(<span class="string">"SERVICE: 创建任务请求处理完成。"</span>);

    <span class="comment">// 返回数据库操作的结果。
    </span>result
}

<span class="doccomment">/// 服务函数：获取所有任务 (Service Function: Get All Tasks)
///
/// 【功能】: 处理获取所有任务的业务逻辑（在这个简单场景下，主要是直接调用 DB 层）。
/// 【输入】: 数据库访问接口 (`db`)。
/// 【输出】: 包含所有 `Task` 实体的向量。
///
/// # 【参数】
/// * `db: &amp;db::Db` - 数据库实例的引用。
///
/// # 【返回值】
/// * `-&gt; Vec&lt;Task&gt;`: 返回包含所有任务的向量。
///   【注意】: 这里直接返回 `Vec&lt;Task&gt;` 而不是 `Result&lt;Vec&lt;Task&gt;&gt;`，
///            隐含的假设是获取所有任务的操作本身不太可能失败（在内存实现中是这样）。
///            在真实的数据库场景中，即使是读取操作也可能因为连接问题等失败，
///            通常会返回 `Result&lt;Vec&lt;Task&gt;&gt;`。
</span><span class="kw">pub async fn </span>get_all_tasks(db: <span class="kw-2">&amp;</span>db::Db) -&gt; Vec&lt;Task&gt; {
    <span class="comment">// --- 业务逻辑占位符 ---
    // 可能的业务逻辑：
    // - **权限检查**: 是否允许当前用户查看所有任务？
    // - **过滤/分页**: 根据用户角色或其他条件过滤任务，或者实现分页逻辑（但通常分页参数来自 Controller）。
    </span><span class="macro">println!</span>(<span class="string">"SERVICE: 正在处理获取所有任务请求..."</span>);

    <span class="comment">// --- 调用数据访问层 ---
    // 直接调用 `db.rs` 中的 `get_all_tasks` 函数。
    </span><span class="kw">let </span>tasks = db::get_all_tasks(db);

    <span class="macro">println!</span>(<span class="string">"SERVICE: 获取所有任务请求处理完成，找到 {} 个任务"</span>, tasks.len());

    <span class="comment">// 返回从数据库获取的任务列表。
    </span>tasks
}

<span class="doccomment">/// 服务函数：根据 ID 获取任务 (Service Function: Get Task By ID)
///
/// 【功能】: 处理根据唯一 ID 检索单个任务的业务逻辑。
/// 【输入】: 数据库访问接口 (`db`) 和 任务 ID (`id`)。
/// 【输出】: 一个包含找到的 `Task` 或错误的 `Result`。
///
/// # 【参数】
/// * `db: &amp;db::Db` - 数据库实例的引用。
/// * `id: Uuid` - 要检索的任务的 UUID。[[所有权: 拷贝]]
///
/// # 【返回值】
/// * `-&gt; Result&lt;Task&gt;`: 返回 `Result`。
///    - `Ok(Task)`: 成功找到任务。
///    - `Err(AppError::TaskNotFound)`: 未找到任务。
</span><span class="kw">pub async fn </span>get_task_by_id(db: <span class="kw-2">&amp;</span>db::Db, id: Uuid) -&gt; <span class="prelude-ty">Result</span>&lt;Task&gt; {
    <span class="comment">// --- 业务逻辑占位符 ---
    // 可能的业务逻辑：
    // - **权限检查**: 当前用户是否有权查看这个特定的任务？（例如，只能看自己创建的任务）。
    // - **数据转换**: 如果需要将数据库模型转换为不同的 DTO 返回给上层。
    </span><span class="macro">println!</span>(<span class="string">"SERVICE: 正在处理获取任务 ID: {} 的请求..."</span>, id);

    <span class="comment">// --- 调用数据访问层 ---
    // 调用 `db.rs` 中的 `get_task_by_id` 函数。
    </span><span class="kw">let </span>result = db::get_task_by_id(db, id);

    <span class="kw">match </span><span class="kw-2">&amp;</span>result {
        <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"SERVICE: 获取任务 ID: {} 的请求处理成功。"</span>, id),
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"SERVICE: 获取任务 ID: {} 的请求处理失败（未找到）。"</span>, id),
    }

    <span class="comment">// 返回数据库操作的结果。
    </span>result
}

<span class="doccomment">/// 服务函数：更新任务 (Service Function: Update Task)
///
/// 【功能】: 处理更新现有任务的业务逻辑。
/// 【输入】: 数据库访问接口 (`db`)，要更新的任务 ID (`id`)，以及包含更新信息的载荷 (`payload`)。
/// 【输出】: 一个包含更新后 `Task` 或错误的 `Result`。
///
/// # 【参数】
/// * `db: &amp;db::Db` - 数据库实例的引用。
/// * `id: Uuid` - 要更新的任务的 UUID。[[所有权: 拷贝]]
/// * `payload: UpdateTaskPayload` - 包含可选更新字段的数据。[[所有权: 移动]]
///
/// # 【返回值】
/// * `-&gt; Result&lt;Task&gt;`: 返回 `Result`。
///    - `Ok(Task)`: 成功更新任务，返回更新后的任务状态。
///    - `Err(AppError::TaskNotFound)`: 未找到要更新的任务。
///    - `Err(AppError::...)`: 其他可能的业务逻辑错误。
</span><span class="kw">pub async fn </span>update_task(db: <span class="kw-2">&amp;</span>db::Db, id: Uuid, payload: UpdateTaskPayload) -&gt; <span class="prelude-ty">Result</span>&lt;Task&gt; {
    <span class="comment">// --- 业务逻辑占位符 ---
    // 可能的业务逻辑：
    // 1. **权限检查**: 用户是否有权修改这个任务？
    // 2. **状态检查**: 任务是否处于允许修改的状态？（例如，已完成的任务可能不允许修改标题）
    // 3. **输入验证**: 对 `payload` 中的字段进行更复杂的验证。
    // 4. **部分更新处理**: 确保只更新了 `payload` 中实际提供的字段。
    // 5. **审计日志**: 记录谁在何时修改了哪些字段。
    </span><span class="macro">println!</span>(<span class="string">"SERVICE: 正在处理更新任务 ID: {} 的请求..."</span>, id);

    <span class="comment">// --- 解构 Payload ---
    // 将 `payload` 中的可选字段解构出来。
    </span><span class="kw">let </span>UpdateTaskPayload { title, description, completed } = payload;

    <span class="comment">// --- 调用数据访问层 ---
    // 调用 `db.rs` 中的 `update_task` 函数。
    // 将 ID 和解构出来的可选字段传递给它。
    </span><span class="kw">let </span>result = db::update_task(db, id, title, description, completed);

    <span class="kw">match </span><span class="kw-2">&amp;</span>result {
        <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"SERVICE: 更新任务 ID: {} 的请求处理成功。"</span>, id),
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"SERVICE: 更新任务 ID: {} 的请求处理失败（未找到或其他错误）。"</span>, id),
    }

    <span class="comment">// 返回数据库操作的结果。
    </span>result
}

<span class="doccomment">/// 服务函数：删除任务 (Service Function: Delete Task)
///
/// 【功能】: 处理删除任务的业务逻辑。
/// 【输入】: 数据库访问接口 (`db`) 和 要删除的任务 ID (`id`)。
/// 【输出】: 一个包含被删除 `Task` 或错误的 `Result`。
///
/// # 【参数】
/// * `db: &amp;db::Db` - 数据库实例的引用。
/// * `id: Uuid` - 要删除的任务的 UUID。[[所有权: 拷贝]]
///
/// # 【返回值】
/// * `-&gt; Result&lt;Task&gt;`: 返回 `Result`。
///    - `Ok(Task)`: 成功删除任务，返回被删除的任务数据（有时可能只返回 `Ok(())` 表示成功）。
///    - `Err(AppError::TaskNotFound)`: 未找到要删除的任务。
///    - `Err(AppError::...)`: 其他可能的业务逻辑错误（例如，权限不足）。
</span><span class="kw">pub async fn </span>delete_task(db: <span class="kw-2">&amp;</span>db::Db, id: Uuid) -&gt; <span class="prelude-ty">Result</span>&lt;Task&gt; {
    <span class="comment">// --- 业务逻辑占位符 ---
    // 可能的业务逻辑：
    // 1. **权限检查**: 用户是否有权删除这个任务？
    // 2. **依赖检查**: 是否有其他数据依赖于这个任务，导致不能删除？
    // 3. **软删除**: 可能不是真的从数据库删除，而是标记为"已删除"（添加 `deleted_at` 字段）。
    // 4. **审计日志**: 记录删除操作。
    </span><span class="macro">println!</span>(<span class="string">"SERVICE: 正在处理删除任务 ID: {} 的请求..."</span>, id);

    <span class="comment">// --- 调用数据访问层 ---
    // 调用 `db.rs` 中的 `delete_task` 函数。
    </span><span class="kw">let </span>result = db::delete_task(db, id);

    <span class="kw">match </span><span class="kw-2">&amp;</span>result {
        <span class="prelude-val">Ok</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"SERVICE: 删除任务 ID: {} 的请求处理成功。"</span>, id),
        <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">println!</span>(<span class="string">"SERVICE: 删除任务 ID: {} 的请求处理失败（未找到或其他错误）。"</span>, id),
    }

    <span class="comment">// 返回数据库操作的结果。
    </span>result
}
</code></pre></div></section></main></body></html>