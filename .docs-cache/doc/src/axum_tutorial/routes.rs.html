<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src\routes.rs`."><title>routes.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="axum_tutorial" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.1 (4eb161250 2025-03-15)" data-channel="1.85.1" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../../static.files/src-script-56102188.js"></script><script defer src="../../src-files.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">axum_tutorial/</div>routes.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers">
<a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a></pre></div><pre class="rust"><code><span class="comment">// routes.rs
//
// /------------------------------------------------------------------------------------------------------\
// |                                     【路由定义模块】 (routes.rs)                                     |
// |------------------------------------------------------------------------------------------------------|
// |                                                                                                      |
// | 1. **导入依赖**:                                                                                     |
// |    - `axum::routing::{get, post, ...}, Router`: Axum 路由构建组件。                                 |
// |    - `tower_http::services::ServeDir`: 用于提供静态文件服务。                                       |
// |    - `crate::app::controller::*`: 控制器层的处理函数和共享状态 (`AppState`)。                        |
// |                                                                                                      |
// | 2. **`create_routes` 函数**: 公共函数，负责创建和配置整个应用的路由。                                  |
// |    - **输入**: `app_state: AppState` (包含数据库连接池等共享状态)。                                  |
// |    - **输出**: `axum::Router` (配置好的路由实例)。                                                  |
// |    - **内部逻辑**:                                                                                     |
// |      a. **创建 API 路由 (`api_routes`)**:                                                            |
// |         - `Router::new()`: 创建一个新的路由实例。                                                  |
// |         - `.route("/path", method(handler))`: 定义路由规则。 [[Axum 核心概念: 路由定义]]         |
// |           - `"/path"`: URL 路径 (可以是静态路径 `/tasks` 或带参数路径 `/tasks/:id`)。             |
// |           - `method`: HTTP 方法 (如 `get`, `post`, `put`, `delete`)。                              |
// |           - `handler`: 当请求匹配路径和方法时调用的【控制器函数】 (例如 `get_all_tasks`)。        |
// |         - `.with_state(app_state.clone())`: 将共享状态 `AppState` 注入到 `api_routes` 的所有        |
// |           处理器中。[[Axum 核心概念: 状态共享]] Axum 会自动将 State 作为参数传递给处理器。         |
// |           (需要克隆 `Arc&lt;T&gt;` 类型的 `app_state`)。                                                |
// |      b. **创建 WebSocket 路由 (`ws_routes`)**:                                                       |
// |         - 类似地定义 `/ws` 路径的 GET 请求，并映射到 `ws_handler`。                                |
// |      c. **组合路由**:                                                                                |
// |         - `Router::new()`: 创建最终的主路由。                                                    |
// |         - `.nest("/api", api_routes)`: 将 `api_routes` 下的所有路由挂载到 `/api` 前缀下。          |
// |           例如，`/tasks` 变成 `/api/tasks`。[[Axum 功能: 嵌套路由]]                              |
// |         - `.merge(ws_routes)`: 将 `ws_routes` 合并到主路由中。[[Axum 功能: 合并路由]]               |
// |         - `.nest_service("/", ServeDir::new("static"))`: 将根路径 `/` 下的所有请求（未被上面   |
// |           路由匹配的）交给 `ServeDir` 服务处理，用于提供 `static` 目录下的静态文件 (如 HTML, CSS)。 |
// |           [[Axum 功能: 静态文件服务]]                                                            |
// |                                                                                                      |
// \------------------------------------------------------------------------------------------------------/
//
// 【核心职责】: 定义应用程序的 URL 结构，将外部 HTTP 请求精确地导向到内部的业务逻辑处理函数（控制器）。
// 【关键技术】: Axum Router (`axum::Router`), HTTP 方法映射 (`get`, `post`), 状态注入 (`with_state`), 路由组织 (`nest`, `merge`), 静态文件服务 (`ServeDir`).

// --- 导入依赖 ---
// `axum::routing::{...}`: 导入 Axum 用于定义路由和 HTTP 方法处理器的函数。
// `Router`: Axum 的核心路由构建器类型。
</span><span class="kw">use </span>axum::{ routing::{ get, post, put, delete }, Router };
<span class="comment">// `tower_http::services::ServeDir`: 导入 Tower HTTP 库提供的服务，用于从目录提供静态文件。
</span><span class="kw">use </span>tower_http::services::ServeDir;

<span class="comment">// --- 导入控制器层组件 ---
// 导入在 `src/app/controller/` 模块中定义的处理函数和共享应用状态 `AppState`。
// 这是路由层与控制器层的连接点。
</span><span class="kw">use </span><span class="kw">crate</span>::app::controller::{ <span class="comment">// 导入控制器函数
    </span>create_task, <span class="comment">// 处理 POST /api/tasks
    </span>delete_task, <span class="comment">// 处理 DELETE /api/tasks/:id
    </span>get_all_tasks, <span class="comment">// 处理 GET /api/tasks
    </span>get_task_by_id, <span class="comment">// 处理 GET /api/tasks/:id
    </span>update_task, <span class="comment">// 处理 PUT /api/tasks/:id 
    </span>ws_handler, <span class="comment">// 处理 GET /ws
    </span>AppState, <span class="comment">// 导入共享应用状态类型
</span>};

<span class="comment">// --- 路由创建函数 ---

</span><span class="doccomment">/// 创建并配置应用程序的所有路由 (Function to Create Application Routes)
///
/// 【功能】: 集中定义应用程序的 URL 结构，并将每个 URL 路径 + HTTP 方法组合映射到相应的控制器处理函数。
///          同时，配置状态共享和静态文件服务。
///
/// # 【参数】
/// * `app_state: AppState` - 应用程序的共享状态。[[所有权: 移动]]
///                           它通常包含数据库连接池 (`Db`) 或其他需要在多个请求处理函数之间共享的资源。
///                           这个 `AppState` 会被注入到需要它的路由处理函数中。
///
/// # 【返回值】
/// * `-&gt; Router`: 返回一个完全配置好的 `axum::Router` 实例。
///                这个 `Router` 实例随后会被传递给 `axum::serve` 来启动服务器。
</span><span class="kw">pub fn </span>create_routes(app_state: AppState) -&gt; Router {
    <span class="comment">// --- 定义 API 相关路由 ---
    // 创建一个专门用于处理 `/api` 前缀下所有请求的子路由。
    </span><span class="kw">let </span>api_routes = Router::new()
        <span class="comment">// 定义 GET /tasks 路由，映射到 get_all_tasks 控制器函数。调用.route() 方法来定义一个路由。返回一个 Router&lt;AppState&gt; 实例。
        // 这个 Router 实例是“携带”了 AppState 这种共享状态的。处理函数可以访问到 AppState 中包含的数据
        // 注意: 同一个路径 "/tasks" 可以根据 HTTP 方法 (GET vs POST) 映射到不同的处理函数。
        </span>.route(<span class="string">"/tasks"</span>, get(get_all_tasks))
        <span class="comment">// 定义 POST /tasks 路由，映射到 create_task 控制器函数。
        // 注意: 同一个路径 "/tasks" 可以根据 HTTP 方法 (GET vs POST) 映射到不同的处理函数。
        </span>.route(<span class="string">"/tasks"</span>, post(create_task))
        <span class="comment">// 定义 GET /tasks/:id 路由，映射到 get_task_by_id 控制器函数。
        // `:id` 是一个【路径参数】(Path Parameter)。[[Axum 功能: 路径参数]]
        // Axum 会自动解析 URL 中的这部分，并通过 `axum::extract::Path` 提取器将其传递给处理函数。
        </span>.route(<span class="string">"/tasks/:id"</span>, get(get_task_by_id))
        <span class="comment">// 定义 PUT /tasks/:id 路由，映射到 update_task 控制器函数。
        </span>.route(<span class="string">"/tasks/:id"</span>, put(update_task))
        <span class="comment">// 定义 DELETE /tasks/:id 路由，映射到 delete_task 控制器函数。
        </span>.route(<span class="string">"/tasks/:id"</span>, delete(delete_task))
        <span class="comment">// --- 注入共享状态 ---
        // `.with_state(app_state.clone())`: 将 `app_state` 注入到上面定义的所有 API 路由的处理函数中。
        // **重要**: 因为 `AppState` 通常包含 `Arc&lt;...&gt;` 类型（如我们的 `Db`），所以克隆 `app_state` 是一个廉价的操作
        //           (只会增加 `Arc` 的引用计数，不会复制内部数据)。[[所有权: 克隆 Arc]]
        //           Axum 要求 State 必须是 `Clone` 的。
        //           处理函数可以通过添加 `axum::extract::State&lt;AppState&gt;` 类型的参数来访问这个状态。
        </span>.with_state(app_state.clone()); <span class="comment">// 使用 `.clone()` 传递 Arc 包装的状态

    // --- 定义 WebSocket 相关路由 ---
    // 创建一个处理 WebSocket 连接的子路由。
    </span><span class="kw">let </span>ws_routes = Router::new()
        <span class="comment">// 定义 GET /ws 路由，映射到 ws_handler 控制器函数，用于处理 WebSocket 升级请求。
        </span>.route(<span class="string">"/ws"</span>, get(ws_handler))
        <span class="comment">// WebSocket 通常不需要共享数据库状态，所以这里没有 `.with_state()`。
        // 如果需要，也可以像 api_routes 一样添加 `.with_state()`。
        </span>.with_state(app_state); <span class="comment">// 如果 ws_handler 需要 AppState，也注入

    // --- 组合所有路由 ---
    // 创建最终的根路由，并将上面定义的子路由和静态文件服务组合起来。
    </span>Router::new()
        <span class="comment">// `.nest("/api", api_routes)`: 将 `api_routes` 下定义的所有路由挂载到 `/api` 路径前缀下。
        // 例如，之前定义的 `/tasks` 会变成 `/api/tasks`。
        // 这有助于组织路由，将所有 API 相关端点归类。
        </span>.nest(<span class="string">"/api"</span>, api_routes)
        <span class="comment">// `.merge(ws_routes)`: 将 `ws_routes` 定义的路由合并到当前路由层级。
        // 这里 `/ws` 路由仍然是根路径下的 `/ws`。
        </span>.merge(ws_routes)
        <span class="comment">// `.nest_service("/", ServeDir::new("static"))`: 配置静态文件服务。
        //   - `"/"`: 匹配根路径及其下的所有子路径（如果未被前面的路由匹配）。
        //   - `ServeDir::new("static")`: 创建一个服务，它会查找并返回 `static` 目录下对应的文件。
        //   - `nest_service`: 将一个 `Service` (实现了 Tower 的 `Service` trait) 挂载到指定的路径下。
        //   【效果】: 当请求 `http://localhost:3000/` 时，会返回 `static/index.html`。
        //           当请求 `http://localhost:3000/styles.css` 时，会返回 `static/styles.css`。
        //           这对于提供前端页面、CSS、JavaScript 文件非常有用。
        // **重要**: 静态文件服务通常放在路由定义的【最后】，因为它会匹配所有未被前面更具体路由捕获的路径。
        </span>.nest_service(<span class="string">"/"</span>, ServeDir::new(<span class="string">"static"</span>))
}
</code></pre></div></section></main></body></html>