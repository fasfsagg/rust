# 服务层 (Service) 核心概念

## 1. 职责与定位

服务层 (`src/app/service/`) 是应用程序【业务逻辑的核心】所在。它位于控制器层 (Controller) 和数据访问层 (DB) 之间，扮演着协调者的角色。其主要职责包括：

- **封装业务规则**: 实现应用程序独有的业务流程、计算和校验逻辑。例如，用户注册时密码复杂度的要求、订单创建时库存的检查与扣减、任务状态流转的规则等。
- **协调数据操作**: 根据业务需求，调用一个或多个数据访问层 (`db.rs`) 提供的函数来完成数据的持久化和检索。服务层本身不关心数据如何存储。
- **事务管理**: 对于需要原子性保证的复杂操作（涉及多个数据更改），服务层负责启动、提交或回滚数据库事务（本项目内存数据库未显式体现）。
- **提供清晰的接口**: 向控制器层暴露定义良好的函数接口，隐藏底层的数据访问细节和复杂的业务流程。

**关键点**: 服务层应该【独立于】具体的 Web 框架 (Axum) 和数据存储实现 (内存 HashMap)。它只关注业务逻辑本身。

## 2. `task_service.rs` 示例

本项目中的 `task_service.rs` 是一个相对简单的服务层实现，主要体现了协调作用：

- **函数命名**: 通常采用 `_svc` 后缀（如 `create_task_svc`）或明确的操作名称来区分于底层的 `db` 函数。
- **参数传递**: 
    - `db: &Db`: 接收数据访问层的接口（依赖注入）。
    - `Payload` (如 `CreateTaskPayload`): 接收来自 Controller 的输入数据。
    - `id`, etc.: 接收操作所需的标识符或其他参数。
- **返回值**: 通常返回 `Result<T>`，其中 `T` 是业务操作的结果（如 `Task` 实例），`Err` 是自定义的 `AppError`，封装了业务或数据访问中可能出现的错误。
- **业务逻辑占位符**: 代码中通过注释标明了可以添加更复杂业务逻辑的位置（如验证、权限检查、审计日志等）。在实际项目中，这些部分会更加充实。
- **直接调用 DB 层**: 由于业务逻辑简单，大部分服务函数目前是直接调用对应的 `db` 函数并返回其结果。

## 3. 异步 (`async/await`)

- **设计前瞻性**: 服务层函数被设计为 `async fn`。虽然底层的内存数据库是同步的，但这种设计使得未来切换到异步数据库（如 PostgreSQL、MySQL with `sqlx`）时，服务层的接口签名**不需要改变**，只需在调用数据库函数时加上 `.await`。
- **非阻塞**: `async` 意味着服务层函数在等待数据库操作（或其他 I/O）时不会阻塞线程，可以提高应用程序的并发处理能力。

## 4. 依赖注入与可测试性

- **依赖注入**: 通过将 `Db` 作为参数传入，而不是在函数内部创建或访问全局变量，实现了依赖注入。这使得：
    - **解耦**: 服务层不强依赖于特定的 `Db` 创建方式。
    - **可测试性**: 在单元测试中，可以轻松地传入一个【模拟 (Mock)】的 `Db` 实现，从而可以在不实际访问数据库的情况下测试服务层的业务逻辑。

## 5. 与其他层的关系

- **被控制器层 (Controller) 调用**: 控制器解析 HTTP 请求，提取数据后调用相应的服务层函数来处理业务。
- **调用数据访问层 (DB)**: 服务层根据业务需要，调用 `db.rs` 中的函数来操作数据。
- **使用模型层 (Model)**: 服务层接收模型层定义的 `Payload` 结构体作为输入，并可能返回 `Task` 等模型结构体作为结果。
- **使用错误处理层 (Error)**: 服务层函数通常返回自定义的 `Result` 类型，并在出错时构造并返回 `AppError`。 